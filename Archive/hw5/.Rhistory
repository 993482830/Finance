new_index[1,] = current
new_index[2,] = current
current = c(data[4053, 2],data[4053,3], IV_Call_SPX,IV_Put_SPX,IV_Call_DJX,IV_Put_DJX)
new_index[2,] = current
new_index[3,] = current
help(array)
new_index = aperm(array(1, dim = c(I,6)), perm = current)
new_index = aperm(array(current, dim = c(I,6)))
new_index = aperm(array(current, dim = c(6,I)))
help("aperm")
head(new_index)
new_index*a
head(a)
head(r)
new_index.*a
head(new_index%*%a)
head(as.matrix(new_index)%*%a)
head(as.matrix(new_index)%*%as.matrix(a))
z=c(1,2)
x=c(2,3)
z%*%x
z%*x
z*x
head(new_index)
new_index[1,1]
typeof(new_index[1,1])
new_index[1,1,1]
new_index = (array(current, dim = c(6,I)))
new_index = aperm(array(current, dim = c(6,I)))
typeof(r[1,1])
typeof(new_index[1,1])
typeof(as.matrix(new_index[1,1]))
typeof(as.numeric(new_index[1,1]))
as.numeric(new_index[1,1])
current
current[1]
as.numeric(current)
new_index = aperm(array(as.numeric(current), dim = c(6,I)))
head(new_index)*a
head(a)
head(new_index*a)
head(new_index)
new_index = new_index*a
new_index = aperm(array(as.numeric(current), dim = c(6,I)))
new_index = new_index*exp(a)
head(new_index)
i=1
new_index[i,1]
new_value = array(0, I)
for (i in 1:I){
val_1 = -50 *BS_Call_div(new_index[i,1] 1865, 0.0025, 0.0222, IV_Call_SPX, 35/365)
val_2 = -50 *BS_Put_div(new_index[i,1], 1865, 0.0025, 0.0222, IV_Put_SPX, 35/365)
val_3 = 550*BS_Call_div(new_index[i,2], 160, 0.0025, 0.0248, IV_Call_DJX, 35/365)
val_4 = 550*BS_Put_div(new_index[i,2], 160, 0.0025, 0.0248, IV_Put_DJX, 35/365)
current_val = val_1 + val_2 + val_3 + val_4
new_value[i] = current_val
}
IV_Call_SPX
for (i in 1:I){
val_1 = -50 *BS_Call_div(new_index[i,1] 1865, 0.0025, 0.0222, IV_Call_SPX$minimum, 35/365)
val_2 = -50 *BS_Put_div(new_index[i,1], 1865, 0.0025, 0.0222, IV_Call_SPX$minimum, 35/365)
val_3 = 550*BS_Call_div(new_index[i,2], 160, 0.0025, 0.0248, IV_Call_SPX$minimum, 35/365)
val_4 = 550*BS_Put_div(new_index[i,2], 160, 0.0025, 0.0248, IV_Call_SPX$minimum, 35/365)
current_val = val_1 + val_2 + val_3 + val_4
new_value[i] = current_val
}
i=1
val_1 = -50 *BS_Call_div(new_index[i,1] 1865, 0.0025, 0.0222, IV_Call_SPX$minimum, 35/365)
for (i in 1:I){
val_1 = -50 *BS_Call_div(new_index[i,1], 1865, 0.0025, 0.0222, IV_Call_SPX$minimum, 35/365)
val_2 = -50 *BS_Put_div(new_index[i,1], 1865, 0.0025, 0.0222, IV_Call_SPX$minimum, 35/365)
val_3 = 550*BS_Call_div(new_index[i,2], 160, 0.0025, 0.0248, IV_Call_SPX$minimum, 35/365)
val_4 = 550*BS_Put_div(new_index[i,2], 160, 0.0025, 0.0248, IV_Call_SPX$minimum, 35/365)
current_val = val_1 + val_2 + val_3 + val_4
new_value[i] = current_val
}
head(new_value)
max(new_value)
I = 10000
r = mvrnorm(I,rep(0,4),cov_matrix)
a = cbind(r[,1],r[,2],r[,3],r[,3],r[,4],r[,4])
current = c(data[4053, 2],data[4053,3], IV_Call_SPX,IV_Put_SPX,IV_Call_DJX,IV_Put_DJX)
new_index = aperm(array(as.numeric(current), dim = c(6,I)))
new_index = new_index*exp(a)
new_value = array(0, I)
for (i in 1:I){
val_1 = -50 *BS_Call_div(new_index[i,1], 1865, 0.0025, 0.0222, new_index[i,3], 35/365)
val_2 = -50 *BS_Put_div(new_index[i,1], 1865, 0.0025, 0.0222, new_index[i,4], 35/365)
val_3 = 550*BS_Call_div(new_index[i,2], 160, 0.0025, 0.0248, new_index[i,5], 35/365)
val_4 = 550*BS_Put_div(new_index[i,2], 160, 0.0025, 0.0248, new_index[i,6], 35/365)
current_val = val_1 + val_2 + val_3 + val_4
new_value[i] = current_val
}
current
current = as.numeric(c(data[4053, 2],data[4053,3], IV_Call_SPX,IV_Put_SPX,IV_Call_DJX,IV_Put_DJX))
current
val_1 = -50 *BS_Call_div(current[1], 1865, 0.0025, 0.0222, current[1], 35/365)
val_2 = -50 *BS_Put_div(current[1], 1865, 0.0025, 0.0222, current[1], 35/365)
val_3 = 550*BS_Call_div(current[1], 160, 0.0025, 0.0248, current[1], 35/365)
val_4 = 550*BS_Put_div(current[1], 160, 0.0025, 0.0248, current[1], 35/365)
current_port = val_1 + val_2 + val_3 + val_4
current_port
val_1 = -50 *BS_Call_div(current[1], 1865, 0.0025, 0.0222, current[3], 35/365)
val_2 = -50 *BS_Put_div(current[1], 1865, 0.0025, 0.0222, current[4], 35/365)
val_3 = 550*BS_Call_div(current[2], 160, 0.0025, 0.0248, current[5], 35/365)
val_4 = 550*BS_Put_div(current[2], 160, 0.0025, 0.0248, current[6], 35/365)
current_port = val_1 + val_2 + val_3 + val_4
current_port
I = 10000
r = mvrnorm(I,rep(0,4),cov_matrix)
a = cbind(r[,1],r[,2],r[,3],r[,3],r[,4],r[,4])
current = as.numeric(c(data[4053, 2],data[4053,3], IV_Call_SPX,IV_Put_SPX,IV_Call_DJX,IV_Put_DJX))
new_index = aperm(array(current, dim = c(6,I)))
new_index = new_index*exp(a)
new_value = array(0, I)
for (i in 1:I){
val_1 = -5000 *BS_Call_div(new_index[i,1], 1865, 0.0025, 0.0222, new_index[i,3], 35/365)
val_2 = -5000 *BS_Put_div(new_index[i,1], 1865, 0.0025, 0.0222, new_index[i,4], 35/365)
val_3 = 55000*BS_Call_div(new_index[i,2], 160, 0.0025, 0.0248, new_index[i,5], 35/365)
val_4 = 55000*BS_Put_div(new_index[i,2], 160, 0.0025, 0.0248, new_index[i,6], 35/365)
current_val = val_1 + val_2 + val_3 + val_4
new_value[i] = current_val
}
val_1 = -5000 *BS_Call_div(current[1], 1865, 0.0025, 0.0222, current[3], 35/365)
val_2 = -5000 *BS_Put_div(current[1], 1865, 0.0025, 0.0222, current[4], 35/365)
val_3 = 55000*BS_Call_div(current[2], 160, 0.0025, 0.0248, current[5], 35/365)
val_4 = 55000*BS_Put_div(current[2], 160, 0.0025, 0.0248, current[6], 35/365)
current_port = val_1 + val_2 + val_3 + val_4
current_port
new_value(1)
new_value[1]
head(new_value-current_port)
PnL = new_value - current_port
help(percentile)
??percentile
quantile(PnL, 0.95)
quantile(PnL, 0.05)
length(PnL)
sort(PnL)[500]
sort(PnL)[501]
sort(PnL)[502]
sort(PnL)[501]
quantile(PnL,0.05)
PnL[PnL<-18975.32]
PnL[PnL<=18975.32]
PnL = new_value - current_port
VaR = quantile(PnL, 0.05)
PnL[PnL<=18975.32]
PnL[PnL<=-18975.32]
mean(PnL[PnL<=18975.32])
mean(PnL[PnL<=-18975.32])
data =read.csv("~/Documents/UIUC/2017Spring/FIN567/hw3/hw3.csv")
#data = data[rev(rownames(data)), ]
#rownames(data) <- NULL
#data2 = log(data[1:4053,c(2,3,4,5)])-log(data[2:4054,c(2,3,4,5)])
data2 = log(data[4054:2,c(2,3,4,5)])-log(data[4053:1,c(2,3,4,5)])
data2 = data2[rev(rownames(data2)), ]
colnames(data2) = c("SPXreturn","DJXreturn","VIXreturn","VXDreturn")
data = cbind(data[2:4054,],data2)
#Q1
covariance = array(0,dim=c(4,4,4054))
for (i in 1:4053){
for(j in 1:4){
for (k in 1:4){
covariance[j,k,i+1]=0.06*data2[i,j]*data2[i,k]+0.94*covariance[j,k,i]
}
}
}
cov_matrix = covariance[,,4054]
annual_cov_matrix = cov_matrix*252
std_dev = array(0,dim=4)
day_std_dev = array(0,dim=4)
for (n in 1:4){
std_dev[n]=sqrt(cov_matrix[n,n])*sqrt(252)
day_std_dev[n]=sqrt(cov_matrix[n,n])
}
#Q2
BS_Call_div<- function(S, K, r, q, sigma, T){
x <- c(1)
d1<-(log(S/K)+(r-q+0.5*sigma^2)*T)/(sigma*sqrt(T))
d2<-(log(S/K)+(r-q-0.5*sigma^2)*T)/(sigma*sqrt(T))
x <- S*exp(-q*T)*pnorm(d1)-exp(-r*T)*K*pnorm(d2)
x
}
BS_Put_div<- function(S, K, r, q, sigma, T){
x <- c(1)
d1<-(log(S/K)+(r-q+0.5*sigma^2)*T)/(sigma*sqrt(T))
d2<-(log(S/K)+(r-q-0.5*sigma^2)*T)/(sigma*sqrt(T))
x <- -S*exp(-q*T)*pnorm(-d1) + exp(-r*T)*K*pnorm(-d2)
x
}
IV_Call_SPX <- optimize(f=function(x){abs(BS_Call_div(data[4053,2], 1865, 0.0025, 0.0222, x, 35/365)-(49.5+50.1)/2)}, interval =c(0,1) )[1]
IV_Put_SPX <- optimize(f=function(x){abs(BS_Put_div(data[4053,2], 1865, 0.0025, 0.0222, x, 35/365)-(55.5+56.1)/2)}, interval =c(0,1) )[1]
IV_Call_DJX <- optimize(f=function(x){abs(BS_Call_div(data[4053,3], 160, 0.0025, 0.0248, x, 35/365)-(4.05+3.85)/2)}, interval =c(0,1) )[1]
IV_Put_DJX <- optimize(f=function(x){abs(BS_Put_div(data[4053,3], 160, 0.0025, 0.0248, x, 35/365)-(4.9+4.7)/2)}, interval =c(0,1) )[1]
IV_Call_SPX
IV_Put_SPX
IV_Call_DJX
IV_Put_DJX
#Q3
library("MASS")
I = 10000
r = mvrnorm(I,rep(0,4),cov_matrix)
a = cbind(r[,1],r[,2],r[,3],r[,3],r[,4],r[,4])
current = as.numeric(c(data[4053, 2],data[4053,3], IV_Call_SPX,IV_Put_SPX,IV_Call_DJX,IV_Put_DJX))
new_index = aperm(array(current, dim = c(6,I)))
new_index = new_index*exp(a)
new_value = array(0, I)
for (i in 1:I){
val_1 = -5000 *BS_Call_div(new_index[i,1], 1865, 0.0025, 0.0222, new_index[i,3], 35/365)
val_2 = -5000 *BS_Put_div(new_index[i,1], 1865, 0.0025, 0.0222, new_index[i,4], 35/365)
val_3 = 55000*BS_Call_div(new_index[i,2], 160, 0.0025, 0.0248, new_index[i,5], 35/365)
val_4 = 55000*BS_Put_div(new_index[i,2], 160, 0.0025, 0.0248, new_index[i,6], 35/365)
current_val = val_1 + val_2 + val_3 + val_4
new_value[i] = current_val
}
val_1 = -5000 *BS_Call_div(current[1], 1865, 0.0025, 0.0222, current[3], 35/365)
val_2 = -5000 *BS_Put_div(current[1], 1865, 0.0025, 0.0222, current[4], 35/365)
val_3 = 55000*BS_Call_div(current[2], 160, 0.0025, 0.0248, current[5], 35/365)
val_4 = 55000*BS_Put_div(current[2], 160, 0.0025, 0.0248, current[6], 35/365)
current_port = val_1 + val_2 + val_3 + val_4
PnL = new_value - current_port
VaR = quantile(PnL, 0.05)
VaR
#Q4
mean(PnL[PnL<=VaR])
cov_matrix = covariance[,,4054]
cov_matrix = covariance[,,4054]
cov_matrix
print("1")
print(1)
print(cov_matrix)
print("Question 1, Part (a)")
print("The covariance matrix is: ")
print(cov_matrix)
print("Part(b)")
print("The annualized standard deviations are: ")
print(std_dev)
print("Question 2")
print("The implied volatility for the four options are:")
print(c(IV_Call_SPX,IV_Put_SPX,IV_Call_DJX,IV_Put_DJX))
print("Question 2")
print("The implied volatility for the four options are:")
print(c(IV_Call_SPX$minimum,IV_Put_SPX$minimum,IV_Call_DJX$minimum,IV_Put_DJX$minimum))
print("Question 3")
print("The Value at Risk of the portfolio is:")
print(VaR)
print(as.numeric(VaR))
print("Question 4")
print("The expected shortfall is:")
print(mean(PnL[PnL<=VaR]))
current
a
cov_matrix
head(r)
#Q1
data =read.csv("~/Documents/UIUC/2017Spring/FIN567/hw3/hw3.csv")
#data = data[rev(rownames(data)), ]
#rownames(data) <- NULL
#data2 = log(data[1:4053,c(2,3,4,5)])-log(data[2:4054,c(2,3,4,5)])
data2 = log(data[4054:2,c(2,3,4,5)])-log(data[4053:1,c(2,3,4,5)])
data2 = data2[rev(rownames(data2)), ]
colnames(data2) = c("SPXreturn","DJXreturn","VIXreturn","VXDreturn")
data = cbind(data[2:4054,],data2)
#Q1
covariance = array(0,dim=c(4,4,4054))
for (i in 1:4053){
for(j in 1:4){
for (k in 1:4){
covariance[j,k,i+1]=0.06*data2[i,j]*data2[i,k]+0.94*covariance[j,k,i]
}
}
}
cov_matrix = covariance[,,4054]
annual_cov_matrix = cov_matrix*252
std_dev = array(0,dim=4)
day_std_dev = array(0,dim=4)
for (n in 1:4){
std_dev[n]=sqrt(cov_matrix[n,n])*sqrt(252)
day_std_dev[n]=sqrt(cov_matrix[n,n])
}
print("Question 1, Part (a)")
print("The covariance matrix is: ")
print(cov_matrix)
print("")
print("Part(b)")
print("The annualized standard deviations are: ")
print(std_dev)
print("")
#Q2
BS_Call_div<- function(S, K, r, q, sigma, T){
x <- c(1)
d1<-(log(S/K)+(r-q+0.5*sigma^2)*T)/(sigma*sqrt(T))
d2<-(log(S/K)+(r-q-0.5*sigma^2)*T)/(sigma*sqrt(T))
x <- S*exp(-q*T)*pnorm(d1)-exp(-r*T)*K*pnorm(d2)
x
}
BS_Put_div<- function(S, K, r, q, sigma, T){
x <- c(1)
d1<-(log(S/K)+(r-q+0.5*sigma^2)*T)/(sigma*sqrt(T))
d2<-(log(S/K)+(r-q-0.5*sigma^2)*T)/(sigma*sqrt(T))
x <- -S*exp(-q*T)*pnorm(-d1) + exp(-r*T)*K*pnorm(-d2)
x
}
IV_Call_SPX <- optimize(f=function(x){abs(BS_Call_div(data[4053,2], 1865, 0.0025, 0.0222, x, 35/365)-(49.5+50.1)/2)}, interval =c(0,1) )[1]
IV_Put_SPX <- optimize(f=function(x){abs(BS_Put_div(data[4053,2], 1865, 0.0025, 0.0222, x, 35/365)-(55.5+56.1)/2)}, interval =c(0,1) )[1]
IV_Call_DJX <- optimize(f=function(x){abs(BS_Call_div(data[4053,3], 160, 0.0025, 0.0248, x, 35/365)-(4.05+3.85)/2)}, interval =c(0,1) )[1]
IV_Put_DJX <- optimize(f=function(x){abs(BS_Put_div(data[4053,3], 160, 0.0025, 0.0248, x, 35/365)-(4.9+4.7)/2)}, interval =c(0,1) )[1]
print("Question 2")
print("The implied volatility for the four options are:")
print(c(IV_Call_SPX$minimum,IV_Put_SPX$minimum,IV_Call_DJX$minimum,IV_Put_DJX$minimum))
print("")
#Q3
library("MASS")
I = 10000
r = mvrnorm(I,rep(0,4),cov_matrix)
a = cbind(r[,1],r[,2],r[,3],r[,3],r[,4],r[,4])
current = as.numeric(c(data[4053, 2],data[4053,3], IV_Call_SPX,IV_Put_SPX,IV_Call_DJX,IV_Put_DJX))
new_index = aperm(array(current, dim = c(6,I)))
new_index = new_index*exp(a)
new_value = array(0, I)
for (i in 1:I){
val_1 = -5000 *BS_Call_div(new_index[i,1], 1865, 0.0025, 0.0222, new_index[i,3], 35/365)
val_2 = -5000 *BS_Put_div(new_index[i,1], 1865, 0.0025, 0.0222, new_index[i,4], 35/365)
val_3 = 55000*BS_Call_div(new_index[i,2], 160, 0.0025, 0.0248, new_index[i,5], 35/365)
val_4 = 55000*BS_Put_div(new_index[i,2], 160, 0.0025, 0.0248, new_index[i,6], 35/365)
current_val = val_1 + val_2 + val_3 + val_4
new_value[i] = current_val
}
val_1 = -5000 *BS_Call_div(current[1], 1865, 0.0025, 0.0222, current[3], 35/365)
val_2 = -5000 *BS_Put_div(current[1], 1865, 0.0025, 0.0222, current[4], 35/365)
val_3 = 55000*BS_Call_div(current[2], 160, 0.0025, 0.0248, current[5], 35/365)
val_4 = 55000*BS_Put_div(current[2], 160, 0.0025, 0.0248, current[6], 35/365)
current_port = val_1 + val_2 + val_3 + val_4
PnL = new_value - current_port
VaR = quantile(PnL, 0.05)
print("Question 3")
print("The 5% Value at Risk of the portfolio is:")
print(as.numeric(VaR))
print("")
#Q4
print("Question 4")
print("The expected shortfall is:")
print(mean(PnL[PnL<=VaR]))
data =read.csv("~/Documents/UIUC/2017Spring/FIN567/hw3/hw3.csv")
data =read.csv("~/Documents/UIUC/2017Spring/FIN567/hw3/hw3.csv")
#data = data[rev(rownames(data)), ]
#rownames(data) <- NULL
#data2 = log(data[1:4053,c(2,3,4,5)])-log(data[2:4054,c(2,3,4,5)])
data2 = log(data[4054:2,c(2,3,4,5)])-log(data[4053:1,c(2,3,4,5)])
data2 = data2[rev(rownames(data2)), ]
colnames(data2) = c("SPXreturn","DJXreturn","VIXreturn","VXDreturn")
data = cbind(data[2:4054,],data2)
#Q1
covariance = array(0,dim=c(4,4,4054))
for (i in 1:4053){
for(j in 1:4){
for (k in 1:4){
covariance[j,k,i+1]=0.06*data2[i,j]*data2[i,k]+0.94*covariance[j,k,i]
}
}
}
cov_matrix = covariance[,,4054]
annual_cov_matrix = cov_matrix*252
std_dev = array(0,dim=4)
day_std_dev = array(0,dim=4)
for (n in 1:4){
std_dev[n]=sqrt(cov_matrix[n,n])*sqrt(252)
day_std_dev[n]=sqrt(cov_matrix[n,n])
}
print("Question 1, Part (a)")
print("The covariance matrix is: ")
print(cov_matrix)
print("")
print("Part(b)")
print("The annualized standard deviations are: ")
print(std_dev)
print("")
source('~/Documents/UIUC/2017Spring/FIN567/hw3/hw3.r', echo=TRUE)
data =read.csv("~/Documents/UIUC/2017Spring/FIN567/hw3/hw3.csv")
#data = data[rev(rownames(data)), ]
#rownames(data) <- NULL
#data2 = log(data[1:4053,c(2,3,4,5)])-log(data[2:4054,c(2,3,4,5)])
data2 = log(data[4054:2,c(2,3,4,5)])-log(data[4053:1,c(2,3,4,5)])
data2 = data2[rev(rownames(data2)), ]
colnames(data2) = c("SPXreturn","DJXreturn","VIXreturn","VXDreturn")
data = cbind(data[2:4054,],data2)
#Q1
covariance = array(0,dim=c(4,4,4054))
for (i in 1:4053){
for(j in 1:4){
for (k in 1:4){
covariance[j,k,i+1]=0.06*data2[i,j]*data2[i,k]+0.94*covariance[j,k,i]
}
}
}
cov_matrix = covariance[,,4054]
annual_cov_matrix = cov_matrix*252
std_dev = array(0,dim=4)
day_std_dev = array(0,dim=4)
for (n in 1:4){
std_dev[n]=sqrt(cov_matrix[n,n])*sqrt(252)
day_std_dev[n]=sqrt(cov_matrix[n,n])
}
print("Question 1, Part (a)")
print("The covariance matrix is: ")
print(cov_matrix)
print("")
print("Part(b)")
print("The annualized standard deviations are: ")
print(std_dev)
print("")
BS_Call_div<- function(S, K, r, q, sigma, T){
x <- c(1)
d1<-(log(S/K)+(r-q+0.5*sigma^2)*T)/(sigma*sqrt(T))
d2<-(log(S/K)+(r-q-0.5*sigma^2)*T)/(sigma*sqrt(T))
x <- S*exp(-q*T)*pnorm(d1)-exp(-r*T)*K*pnorm(d2)
x
}
BS_Put_div<- function(S, K, r, q, sigma, T){
x <- c(1)
d1<-(log(S/K)+(r-q+0.5*sigma^2)*T)/(sigma*sqrt(T))
d2<-(log(S/K)+(r-q-0.5*sigma^2)*T)/(sigma*sqrt(T))
x <- -S*exp(-q*T)*pnorm(-d1) + exp(-r*T)*K*pnorm(-d2)
x
}
IV_Call_SPX <- optimize(f=function(x){abs(BS_Call_div(data[4053,2], 1865, 0.0025, 0.0222, x, 35/365)-(49.5+50.1)/2)}, interval =c(0,1) )[1]
IV_Put_SPX <- optimize(f=function(x){abs(BS_Put_div(data[4053,2], 1865, 0.0025, 0.0222, x, 35/365)-(55.5+56.1)/2)}, interval =c(0,1) )[1]
IV_Call_DJX <- optimize(f=function(x){abs(BS_Call_div(data[4053,3], 160, 0.0025, 0.0248, x, 35/365)-(4.05+3.85)/2)}, interval =c(0,1) )[1]
IV_Put_DJX <- optimize(f=function(x){abs(BS_Put_div(data[4053,3], 160, 0.0025, 0.0248, x, 35/365)-(4.9+4.7)/2)}, interval =c(0,1) )[1]
print("Question 2")
print("The implied volatility for the four options are:")
print(c(IV_Call_SPX$minimum,IV_Put_SPX$minimum,IV_Call_DJX$minimum,IV_Put_DJX$minimum))
#Q3
library("MASS")
I = 10000
r = mvrnorm(I,rep(0,4),cov_matrix)
a = cbind(r[,1],r[,2],r[,3],r[,3],r[,4],r[,4])
current = as.numeric(c(data[4053, 2],data[4053,3], IV_Call_SPX,IV_Put_SPX,IV_Call_DJX,IV_Put_DJX))
new_index = aperm(array(current, dim = c(6,I)))
new_index = new_index*exp(a)
new_value = array(0, I)
for (i in 1:I){
val_1 = -5000 *BS_Call_div(new_index[i,1], 1865, 0.0025, 0.0222, new_index[i,3], 35/365)
val_2 = -5000 *BS_Put_div(new_index[i,1], 1865, 0.0025, 0.0222, new_index[i,4], 35/365)
val_3 = 55000*BS_Call_div(new_index[i,2], 160, 0.0025, 0.0248, new_index[i,5], 35/365)
val_4 = 55000*BS_Put_div(new_index[i,2], 160, 0.0025, 0.0248, new_index[i,6], 35/365)
current_val = val_1 + val_2 + val_3 + val_4
new_value[i] = current_val
}
val_1 = -5000 *BS_Call_div(current[1], 1865, 0.0025, 0.0222, current[3], 35/365)
val_2 = -5000 *BS_Put_div(current[1], 1865, 0.0025, 0.0222, current[4], 35/365)
val_3 = 55000*BS_Call_div(current[2], 160, 0.0025, 0.0248, current[5], 35/365)
val_4 = 55000*BS_Put_div(current[2], 160, 0.0025, 0.0248, current[6], 35/365)
current_port = val_1 + val_2 + val_3 + val_4
PnL = new_value - current_port
VaR = quantile(PnL, 0.05)
print("Question 3")
print("The 5% Value at Risk of the portfolio is:")
print(as.numeric(VaR))
#Q4
print("Question 4")
print("The expected shortfall is:")
print(mean(PnL[PnL<=VaR]))
25^2
51-44
13*41
3/16
setwd("/Users/user/Documents/UIUC/2017Spring/FIN567/hw5")
#Question 1:
#Part a:
#------:
library(quantmod)
#get the data
getSymbols("^GSPC")
sp <- GSPC[,6]
sp <- as.data.frame(sp)
colnames(sp) <- "Prices"
rm(GSPC)
sp <- na.omit(sp)
View(sp)
#compute log returns
sp$temp <- log(sp$Prices)
sp$logreturns[2:nrow(sp)]<- diff(sp$temp, lag=1)
sp<- sp[-2]
View(sp)
start=2552-999
end=2552
sp_subset<- (sp$logreturns[start:end])^2
sp_subset<- as.data.frame(sp_subset)
sample_variance<- mean(sp_subset[,1])
first_variance<- mean(sp_subset$sp_subset[980:1000])
#MLE Function
sigma_sq = rep(0, 1000)
l=0
log_likelihood <- function (theta)
{
l1 = -0.5*(log(theta[1]) + sp_subset[1,1]/theta[1])
sigma_sq[1]=theta[1]
l=l1
for (i in 2:1000)
{
sigma_sq[i] = (1-theta[2] - theta[3])*theta[4]+theta[2]*sp_subset[i-1,1]+ theta[3]*sigma_sq[i-1]
l = l - 0.5*((log(sigma_sq[i]) + sp_subset[i,1]/sigma_sq[i]))
}
return(-l)
}
initial_value <- c(first_variance, 0.1, 0.1, sample_variance)
u<- rbind(c(1,0,0,0), c(0,1,0,0), c(0,0,1,0), c(0,0,0,1), c(0,-1,-1,0))
c<- c(0,0,0,0,-1)
mle<- constrOptim(initial_value,log_likelihood, grad = NULL, u, c)
mle$par
